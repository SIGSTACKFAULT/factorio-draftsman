# 2.0 release

manner of validation

```python
blueprint = Blueprint()

blueprint.load_from_string("...")
try:
    blueprint.raise_for_status()
except DraftsmanError:
    raise
```

## Problems:
* Can only resolve one error

```python
blueprint = Blueprint()

blueprint.load_from_string("...") # Can still raise MalformedBlueprintStringError + IncorrectBlueprintTypeError
valid, issues = blueprint.is_valid()
if not valid:
    for issue in issues:
        print(issue.name) # OverlappingObjectsWarning, InvalidEntityError, etc.
        # Handle the issue somehow
```

## True Errors
```
DraftsmanError
IncorrectBlueprintTypeError
DuplicateIDError
InvalidAssociationError
IncompatibleModError
MissingModError
IncorrectModVersionError
IncorrectModFormatError
MalformedBlueprintStringError
```

## Validation Errors
```
InvalidEntityError(?)
InvalidOperationError
InvalidModeError
InvalidWireTypeError
InvalidConnectionSideError
InvalidRecipeError
InvalidModuleError
InvalidInstrumentID
InvalidNoteID
InvalidSideError
InvalidFluidError
EntityNotPowerConnectableError
EntityNotCircuitConnectableError
InvalidTileError
InvalidSignalError
InvalidItemError
```

```python
# Example entity
accumulator = Accumulator()

# Optional validation for entity attributes can be done with an external toggle:
draftsman.entity_validation = True # Toggle
accumulator.control_behavior = {"incorrect": "format"} # DataFormatError

draftsman.entity_validation = False
accumulator.control_behavior = {"incorrect": "format"} # No issue

# For a generic query on whether or not to consider this entity valid, more a quick
# idiot check, we can do:
if not accumulator.is_valid():
    print("This entity is not valid")

# Most likely though, the user will want some control over what parts to consider valid, 
# so something like this makes sense:
if not accumulator.is_valid(DataFormatError, InvalidWireConnectionError)
    # This will ignore all other issues aside from the two issues above
    print("The accumulator has a DataFormatError or an InvalidWireConnectionError!")

# For a more fine grained inquiry, we can search and collect "issues" (Errors + Warnings)
issues = accumulator.collect_issues()
# Similar to above, the user will most likely want some interface to specifically 
# select particular issues over others
# For example, we can separate the issues list into errors and warnings
for error in issues.errors:
    # handle errors

for warning in issues.warnings:
    # handle warnings
```

```python
issues = entity.validate()
for issue in issues:
    pass
```


Signal stuff
------------

We need to be able to specify `entity.signal = {"name": ..., "type": ...}` because since we're getting rid of permanent validation Draftsman might not be able to deduce the type of the signal from its name:

```python
# Assuming a vanilla draftsman install
accumulator = Accumulator()

accumulator.output_signal = "filter-combinator" # This either errors here, as we try to convert to dict
accumulator.validate() # Or here, if we modify the signal name from a string to a dict here
accumulator.to_dict() # Or here, if we try to create a usable dict and we cannot determine the signal type

# instead, we must do
accumulator.output_signal = {"name": "filter-combinator", "type": "item"}
# Or a possible shorthand
accumulator.output_signal = ("filter-combinator", "item")
```

Or, we could add a data function that allows the user to add the signal to the raw data and then everything can stay the same:

```python

from draftsman.data import signals

signals.add_signal("filter-combinator", "item") # Add the signal to signals.raw for the lifetime of this program
# add_signal would also have an optional sort string so it can be placed in correct order to preserve ordering, by default it gets appended

accumulator = Accumulator()
accumulator.output_signal = "filter-combinator" # This causes no errors

```

errors can be issued on regular functions if and only if meaning cannot be deduced from the input arguments
adding something that's not an entity to an entity list, because we only know how to convert entitylikes to json when exporting
TypeErrors on arguments that are integers when they need to be ranges, or strings when they need to be dicts
warnings can also be issued on regular functions, if there is some clear mistake but not critical to operation at this moment
setting an inventory bar to be greater than the inventory size is the classical example; wrong from a strict standpoint, but functionally harmless to importing/exporting
making a blueprint too large would be a warning, because draftsman has no trouble doing this; only trouble arises when exporting
inspect() can be called at any time, which performs complex validation checks, such as checking a blueprint/entity's entire structure
inspect() returns a series of errors and warnings that can be interpreted by the end user or ignored
Exactly what format is up to debate. In two lists, errors and warnings, or all together? Sorted by severity, so when iterating you get the worst ones first?
Finally, during Factorio resolution (to_dict() and to_string()), we call inspect with the same user type idiom of

for issue in blueprint.inspect():
    raise issue

which means any chronic issue that prevents import into Factorio would be raised at this step
NO: the user should be able to break things if they so desire

Format validation vs content validation: they are different! Maybe:

```python

accumulator = Accumulator()
accumulator.output_signal = "signal-A" # Pre-2.0 would be converted to a dict
assert accumulator.output_signal == "signal-A" # though not anymore

# In order to have this change take place, we call validate(), which is distinct from inspect():
accumulator.validate()
assert accumulator.output_signal == {"name": "signal-A", "type": "virtual"}

# if validate went well, we can maybe use this to improve performance. Suppose we create a blueprint and 1000 of the above accumulators to it:

blueprint = Blueprint()
for i in range(1000):
    blueprint.entities.append(accumulator, tile_position=(i*accumulator.tile_width, 0))

# Then, if we were to validate the blueprint, we don't really need to check if the entities are valid because each one is a copy of a blueprint that we know is valid
# So we only have to validate 1 entity instead of 1000
blueprint.validate() # Ideally this would have basically no performance impact

# The question then becomes, should inspect() return format errors/warnings?
```

I'm thinking no. Inspect ideally should handle issues with the contents of blueprints, complex things that are much more involved then a simple formatting check.

Furthermore, we can think about this in terms of output strings as well. `validate()` must be called at some point before `to_dict()` or `to_string()`, because it needs to be resolved to the correct format by nature of the function. However, `inspect()` does *not* need to be called beforehand, or at all; it may resolve in an issue on import, but not one that relates to the format of the passed in object.\

So, validation should not happen on attribute set/get. This behaves more like one would expect, so that any value that is set is immediately retrievable as the same value:

```python
accumulator.output_signal = "signal-A"
assert accumulator.output_signal == "signal-A"
```

If you call `validate()`, this resolves the signal to the correct format expected by Factorio:

```python
accumulator.validate()
assert accumulator.output_signal == {"name": "signal-A", "type": "virtual"}
```

Draftsman is able to infer the extra metadata because `"signal-A"` is recognized in `data`. However, this may not always be the case:

```python
accumulator.output_signal = "some-modded-signal"
assert accumulator.output_signal == "some-modded-signal"

accumulator.validate() # Throws exception!
```

Draftsman throws and *exception* because it cannot possibly know what the `"type"` of that modded signal is; and therefore cannot ensure that the result of converting it to a dict will return a properly formatted blueprint string.

There are a number of ways around this. If signal is *explicitly* defined, either by the user or an imported blueprint, then the validation has everything it needs to know to produce the blueprint string:

```python
accumulator.output_signal = {"name": "some-modded-signal", "type": "virtual"}
assert accumulator.output_signal == {"name": "some-modded-signal", "type": "virtual"}

accumulator.validate() # Fine
```

You can also add the signal to `data` manually and draftsman will recognize it for that python session:

```python
from draftsman.data import signals

signals.add_signal("some-modded-signal", "virtual")

accumulator.output_signal = "some-modded-signal"
assert accumulator.output_signal == "some-modded-signal"

accumulator.validate() # Fine
```

The old method of installing the mod with `"some-modded-signal"` still works as well, of course.

`validate()` is automatically called by `to_dict()` and `to_string()`, so the end user doesn't have to call it. The benefit to splitting it into it's own function is that the user has control of exactly when it takes place. If a user sets a signal many hundreds or thousands of times, the validation only needs to be performed once; if the user wants to set the variable to a different, breaking value, they can (until they want to export it); and theoretically it should allow certain subcomponents to be checked if they're valid and not traverse them if they are.
Should validate use that cache thing that casa-sui mentioned?

`inspect()` is more complex. Instead of asking, "is this value okay?", it asks, "does this value make sense?":

```python
accumulator.output_signal = "some-modded-signal"
assert accumulator.output_signal == "some-modded-signal"

error_list, warning_list = accumulator.inspect() # Does this have to validate accumulator in order to work?
print(warning_list)
# [UnrecognizedElementWarning("Unrecognized signal 'some-modded-signal'")]
```

`inspect()` should create a *human readable* digest, or it should be very easy to coerce to produce a human readable digest. 
`inspect()` is for additional issues that come from a object that otherwise passes it's schema validation.

Errors returned by inspect are guaranteed to fail importing into Factorio, including things like entries being the wrong datatype (or should that be handled by validate?), or the blueprint being too large across one or more of it's axes.
Warnings returned by inspect are everything else; they *can* cause errors (things like unrecognized entities; they might exist in the Factorio context and be fine, but they also might not and raise an error), as well as just regular old useless/redundant keys or values.

validate is for schema correctness, inspect is for any additional restrictions
by that axiom, then things like datatype correctness must be ensured by validate

So validate can operate as a cached property, something like `is_valid`
When checking the validity of some entity, it first checks to see if `is_valid` is `True`, and early exits if so; Otherwise, it goes through the whole validation shebang

This is how we get the 1 -> 1000 performance gain mentioned above; we go through each entity and call `entity.validate()`, and they all are `is_valid` so it skips every one
We then simply set it up so that if any attribute of the entity is modified, it invalidates `is_valid`, so validate must be performed once again at some point before `to_dict()`

What about when creating entities? Does creating a new entity from scratch guarantee that `is_valid` starts as `True`? 
A: No, validate will always have to be called at some point afterwards to ensure that the arguments passed to it were correct. It has a certain level of confidence over it's own structure though; maybe if no arguments are passed then it can consider itself valid? (strange circumstance though, and almost never used. Unlikely to be desirable)